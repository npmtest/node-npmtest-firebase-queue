{"/home/travis/build/npmtest/node-npmtest-firebase-queue/test.js":"/* istanbul instrument in package npmtest_firebase_queue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-queue/lib.npmtest_firebase_queue.js":"/* istanbul instrument in package npmtest_firebase_queue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_firebase_queue = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_firebase_queue = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-queue/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-firebase-queue && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_firebase_queue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_firebase_queue\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_firebase_queue.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_firebase_queue.rollup.js'] =\n            local.assetsDict['/assets.npmtest_firebase_queue.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_firebase_queue.__dirname +\n                    '/lib.npmtest_firebase_queue.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-queue/node_modules/firebase-queue/dist/queue.js":"/*\n * Firebase Queue is a fault-tolerant, multi-worker, multi-stage job pipeline\n * built on Firebase.\n *\n * Firebase Queue 0.0.0\n * https://github.com/firebase/firebase-queue/\n * License: MIT\n */\n'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar logger = require('winston');\nvar QueueWorker = require('./lib/queue_worker.js');\n\nvar DEFAULT_NUM_WORKERS = 1;\nvar DEFAULT_SANITIZE = true;\nvar DEFAULT_SUPPRESS_STACK = false;\nvar DEFAULT_TASK_SPEC = {\n  inProgressState: 'in_progress',\n  timeout: 300000 // 5 minutes\n};\n\n\n/**\n * @constructor\n * @param {firebase.database.Reference|Object} ref A Firebase Realtime Database\n *  reference to the queue or an object containing both keys:\n *     - tasksRef: {firebase.database.Reference} A Firebase Realtime Database\n *         reference to the queue tasks location.\n *     - specsRef: {firebase.database.Reference} A Firebase Realtime Database\n *         reference to the queue specs location.\n * @param {Object} options (optional) Object containing possible keys:\n *     - specId: {String} the task specification ID for the workers.\n *     - numWorkers: {Number} The number of workers to create for this task.\n *     - sanitize: {Boolean} Whether to sanitize the 'data' passed to the\n *         processing function of internal queue keys.\n * @param {Function} processingFunction A function that is called each time to\n *   process a task. This function is passed four parameters:\n *     - data {Object} The current data at the location.\n *     - progress {Function} A function to update the progress percent of the\n *         task for informational purposes. Pass it a number between 0 and 100.\n *         Returns a promise of whether the operation was completed\n *         successfully.\n *     - resolve {Function} An asychronous callback function - call this\n *         function when the processingFunction completes successfully. This\n *         takes an optional Object parameter that, if passed, will overwrite\n *         the data at the task location, and returns a promise of whether the\n *         operation was successful.\n *     - reject {Function} An asynchronous callback function - call this\n *         function if the processingFunction encounters an error. This takes\n *         an optional String or Object parameter that will be stored in the\n *         '_error_details/error' location in the task and returns a promise\n *         of whether the operation was successful.\n * @returns {Object} The new Queue object.\n */\nfunction Queue() {\n  var self = this;\n  var constructorArguments = arguments;\n\n  var error;\n  self.numWorkers = DEFAULT_NUM_WORKERS;\n  self.sanitize = DEFAULT_SANITIZE;\n  self.suppressStack = DEFAULT_SUPPRESS_STACK;\n  self.initialized = false;\n  self.shuttingDown = false;\n\n  self.specChangeListener = null;\n\n  if (constructorArguments.length < 2) {\n    error = 'Queue must at least have the queueRef and ' +\n      'processingFunction arguments.';\n    logger.debug('Queue(): Error during initialization', error);\n    throw new Error(error);\n  } else if (constructorArguments.length === 2) {\n    self.processingFunction = constructorArguments[1];\n  } else if (constructorArguments.length === 3) {\n    var options = constructorArguments[1];\n    if (!_.isPlainObject(options)) {\n      error = 'Options parameter must be a plain object.';\n      logger.debug('Queue(): Error during initialization', error);\n      throw new Error(error);\n    }\n    if (!_.isUndefined(options.specId)) {\n      if (_.isString(options.specId)) {\n        self.specId = options.specId;\n      } else {\n        error = 'options.specId must be a String.';\n        logger.debug('Queue(): Error during initialization', error);\n        throw new Error(error);\n      }\n    }\n    if (!_.isUndefined(options.numWorkers)) {\n      if (_.isNumber(options.numWorkers) &&\n          options.numWorkers > 0 &&\n          options.numWorkers % 1 === 0) {\n        self.numWorkers = options.numWorkers;\n      } else {\n        error = 'options.numWorkers must be a positive integer.';\n        logger.debug('Queue(): Error during initialization', error);\n        throw new Error(error);\n      }\n    }\n    if (!_.isUndefined(options.sanitize)) {\n      if (_.isBoolean(options.sanitize)) {\n        self.sanitize = options.sanitize;\n      } else {\n        error = 'options.sanitize must be a boolean.';\n        logger.debug('Queue(): Error during initialization', error);\n        throw new Error(error);\n      }\n    }\n    if (!_.isUndefined(options.suppressStack)) {\n      if (_.isBoolean(options.suppressStack)) {\n        self.suppressStack = options.suppressStack;\n      } else {\n        error = 'options.suppressStack must be a boolean.';\n        logger.debug('Queue(): Error during initialization', error);\n        throw new Error(error);\n      }\n    }\n    self.processingFunction = constructorArguments[2];\n  } else {\n    error = 'Queue can only take at most three arguments - queueRef, ' +\n      'options (optional), and processingFunction.';\n    logger.debug('Queue(): Error during initialization', error);\n    throw new Error(error);\n  }\n\n  if (_.has(constructorArguments[0], 'tasksRef') &&\n      _.has(constructorArguments[0], 'specsRef')) {\n    self.tasksRef = constructorArguments[0].tasksRef;\n    self.specsRef = constructorArguments[0].specsRef;\n  } else if (_.isPlainObject(constructorArguments[0])) {\n    error = 'When ref is an object it must contain both keys \\'tasksRef\\' ' +\n      'and \\'specsRef\\'';\n    logger.debug('Queue(): Error during initialization', error);\n    throw new Error(error);\n  } else {\n    self.tasksRef = constructorArguments[0].child('tasks');\n    self.specsRef = constructorArguments[0].child('specs');\n  }\n\n  self.workers = [];\n  for (var i = 0; i < self.numWorkers; i++) {\n    var processId = (self.specId ? self.specId + ':' : '') + i;\n    self.workers.push(new QueueWorker(\n      self.tasksRef,\n      processId,\n      self.sanitize,\n      self.suppressStack,\n      self.processingFunction\n    ));\n  }\n\n  if (_.isUndefined(self.specId)) {\n    for (var j = 0; j < self.numWorkers; j++) {\n      self.workers[j].setTaskSpec(DEFAULT_TASK_SPEC);\n    }\n    self.initialized = true;\n  } else {\n    self.specChangeListener = self.specsRef.child(self.specId).on(\n      'value',\n      function(taskSpecSnap) {\n        var taskSpec = {\n          startState: taskSpecSnap.child('start_state').val(),\n          inProgressState: taskSpecSnap.child('in_progress_state').val(),\n          finishedState: taskSpecSnap.child('finished_state').val(),\n          errorState: taskSpecSnap.child('error_state').val(),\n          timeout: taskSpecSnap.child('timeout').val(),\n          retries: taskSpecSnap.child('retries').val()\n        };\n\n        for (var k = 0; k < self.numWorkers; k++) {\n          self.workers[k].setTaskSpec(taskSpec);\n        }\n        self.currentTaskSpec = taskSpec;\n        self.initialized = true;\n      }, /* istanbul ignore next */ function(err) {\n        logger.debug('Queue(): Error connecting to Firebase reference',\n          err.message);\n      });\n  }\n\n  return self;\n}\n\n/**\n * Gracefully shuts down a queue.\n * @returns {RSVP.Promise} A promise fulfilled when all the worker processes\n *   have finished their current tasks and are no longer listening for new ones.\n */\nQueue.prototype.shutdown = function() {\n  this.shuttingDown = true;\n  logger.debug('Queue: Shutting down');\n  if (!_.isNull(this.specChangeListener)) {\n    this.specsRef.child(this.specId).off('value',\n      this.specChangeListener);\n    this.specChangeListener = null;\n  }\n\n  return RSVP.all(_.map(this.workers, function(worker) {\n    return worker.shutdown();\n  }));\n};\n\n/**\n * Gets queue worker count.\n * @returns {Number} Total number of workers for this queue.\n */\nQueue.prototype.getWorkerCount = function() {\n  return this.workers.length;\n};\n\n/**\n * Adds a queue worker.\n * @returns {QueueWorker} the worker created.\n */\nQueue.prototype.addWorker = function() {\n  if (this.shuttingDown) {\n    throw new Error('Cannot add worker while queue is shutting down');\n  }\n\n  logger.debug('Queue: adding worker');\n  var processId = (this.specId ? this.specId + ':' : '') + this.workers.length;\n  var worker = new QueueWorker(\n    this.tasksRef,\n    processId,\n    this.sanitize,\n    this.suppressStack,\n    this.processingFunction\n  );\n  this.workers.push(worker);\n\n  if (_.isUndefined(this.specId)) {\n    worker.setTaskSpec(DEFAULT_TASK_SPEC);\n  // if the currentTaskSpec is not yet set it will be called once it's fetched\n  } else if (!_.isUndefined(this.currentTaskSpec)) {\n    worker.setTaskSpec(this.currentTaskSpec);\n  }\n\n  return worker;\n};\n\n/**\n * Shutdowns a queue worker if one exists.\n * @returns {RSVP.Promise} A promise fulfilled once the worker is shutdown\n *   or rejected if there are no workers left to shutdown.\n */\nQueue.prototype.shutdownWorker = function() {\n  var worker = this.workers.pop();\n\n  var promise;\n  if (_.isUndefined(worker)) {\n    promise = RSVP.reject(new Error('No workers to shutdown'));\n  } else {\n    logger.debug('Queue: shutting down worker');\n    promise = worker.shutdown();\n  }\n\n  return promise;\n};\n\n\nmodule.exports = Queue;\n","/home/travis/build/npmtest/node-npmtest-firebase-queue/node_modules/firebase-queue/dist/lib/queue_worker.js":"'use strict';\n\nvar logger = require('winston');\nvar uuid = require('uuid');\nvar RSVP = require('rsvp');\nvar _ = require('lodash');\n\nvar MAX_TRANSACTION_ATTEMPTS = 10;\nvar DEFAULT_ERROR_STATE = 'error';\nvar DEFAULT_RETRIES = 0;\n\nvar SERVER_TIMESTAMP = {'.sv': 'timestamp'};\n\nfunction _getKey(snapshot) {\n  return _.isFunction(snapshot.key) ? snapshot.key() : snapshot.key;\n}\n\nfunction _getRef(snapshot) {\n  return _.isFunction(snapshot.ref) ? snapshot.ref() : snapshot.ref;\n}\n\n/**\n * @param {firebase.database.Reference} tasksRef the Firebase Realtime Database\n *   reference for queue tasks.\n * @param {String} processId the ID of the current worker process.\n * @param {Function} processingFunction the function to be called each time a\n *   task is claimed.\n * @return {Object}\n */\nfunction QueueWorker(tasksRef, processId, sanitize, suppressStack,\n    processingFunction) {\n  var self = this;\n  var error;\n  if (_.isUndefined(tasksRef)) {\n    error = 'No tasks reference provided.';\n    logger.debug('QueueWorker(): ' + error);\n    throw new Error(error);\n  }\n  if (!_.isString(processId)) {\n    error = 'Invalid process ID provided.';\n    logger.debug('QueueWorker(): ' + error);\n    throw new Error(error);\n  }\n  if (!_.isBoolean(sanitize)) {\n    error = 'Invalid sanitize option.';\n    logger.debug('QueueWorker(): ' + error);\n    throw new Error(error);\n  }\n  if (!_.isBoolean(suppressStack)) {\n    error = 'Invalid suppressStack option.';\n    logger.debug('QueueWorker(): ' + error);\n    throw new Error(error);\n  }\n  if (!_.isFunction(processingFunction)) {\n    error = 'No processing function provided.';\n    logger.debug('QueueWorker(): ' + error);\n    throw new Error(error);\n  }\n\n  self.processId = processId + ':' + uuid.v4();\n  self.shutdownDeferred = null;\n\n  self.processingFunction = processingFunction;\n  self.expiryTimeouts = {};\n  self.owners = {};\n\n  self.tasksRef = tasksRef;\n  self.processingTasksRef = null;\n  self.currentTaskRef = null;\n  self.newTaskRef = null;\n\n  self.currentTaskListener = null;\n  self.newTaskListener = null;\n  self.processingTaskAddedListener = null;\n  self.processingTaskRemovedListener = null;\n\n  self.busy = false;\n  self.taskNumber = 0;\n  self.errorState = DEFAULT_ERROR_STATE;\n  self.sanitize = sanitize;\n  self.suppressStack = suppressStack;\n\n  return self;\n}\n\n/**\n * Logs an info message with a worker-specific prefix.\n * @param {String} message The message to log.\n */\nQueueWorker.prototype._getLogEntry = function(message) {\n  return 'QueueWorker ' + this.processId + ' ' + message;\n};\n\n/**\n * Returns the state of a task to the start state.\n * @param {firebase.database.Reference} taskRef Firebase Realtime Database\n *   reference to the Firebase location of the task that's timed out.\n * @param {Boolean} immediate Whether this is an immediate update to a task we\n *   expect this worker to own, or whether it's a timeout reset that we don't\n *   necessarily expect this worker to own.\n * @returns {RSVP.Promise} Whether the task was able to be reset.\n */\nQueueWorker.prototype._resetTask = function(taskRef, immediate, deferred) {\n  var self = this;\n  var retries = 0;\n\n  /* istanbul ignore else */\n  if (_.isUndefined(deferred)) {\n    deferred = RSVP.defer();\n  }\n\n  taskRef.transaction(function(task) {\n    /* istanbul ignore if */\n    if (_.isNull(task)) {\n      return task;\n    }\n    var id = self.processId + ':' + self.taskNumber;\n    var correctState = (task._state === self.inProgressState);\n    var correctOwner = (task._owner === id || !immediate);\n    var timeSinceUpdate = Date.now() - _.get(task, '_state_changed', 0);\n    var timedOut = ((self.taskTimeout && timeSinceUpdate > self.taskTimeout) || immediate);\n    if (correctState && correctOwner && timedOut) {\n      task._state = self.startState;\n      task._state_changed = SERVER_TIMESTAMP;\n      task._owner = null;\n      task._progress = null;\n      task._error_details = null;\n      return task;\n    }\n    return undefined;\n  }, function(error, committed, snapshot) {\n    /* istanbul ignore if */\n    if (error) {\n      if (++retries < MAX_TRANSACTION_ATTEMPTS) {\n        logger.debug(self._getLogEntry('reset task errored, retrying'), error);\n        setImmediate(self._resetTask.bind(self), taskRef, immediate, deferred);\n      } else {\n        var errorMsg = 'reset task errored too many times, no longer retrying';\n        logger.debug(self._getLogEntry(errorMsg), error);\n        deferred.reject(new Error(errorMsg));\n      }\n    } else {\n      if (committed && snapshot.exists()) {\n        logger.debug(self._getLogEntry('reset ' + _getKey(snapshot)));\n      }\n      deferred.resolve();\n    }\n  }, false);\n\n  return deferred.promise;\n};\n\n/**\n * Creates a resolve callback function, storing the current task number.\n * @param {Number} taskNumber the current task number\n * @returns {Function} the resolve callback function.\n */\nQueueWorker.prototype._resolve = function(taskNumber) {\n  var self = this;\n  var retries = 0;\n  var deferred = RSVP.defer();\n\n  /*\n   * Resolves the current task and changes the state to the finished state.\n   * @param {Object} newTask The new data to be stored at the location.\n   * @returns {RSVP.Promise} Whether the task was able to be resolved.\n   */\n  var resolve = function(newTask) {\n    if ((taskNumber !== self.taskNumber) || _.isNull(self.currentTaskRef)) {\n      if (_.isNull(self.currentTaskRef)) {\n        logger.debug(self._getLogEntry('Can\\'t resolve task - no task ' +\n          'currently being processed'));\n      } else {\n        logger.debug(self._getLogEntry('Can\\'t resolve task - no longer ' +\n          'processing current task'));\n      }\n      deferred.resolve();\n      self.busy = false;\n      self._tryToProcess();\n    } else {\n      var existedBefore;\n      self.currentTaskRef.transaction(function(task) {\n        existedBefore = true;\n        if (_.isNull(task)) {\n          existedBefore = false;\n          return task;\n        }\n        var id = self.processId + ':' + self.taskNumber;\n        if (task._state === self.inProgressState &&\n            task._owner === id) {\n          var outputTask = _.clone(newTask);\n          if (!_.isPlainObject(outputTask)) {\n            outputTask = {};\n          }\n          outputTask._state = _.get(outputTask, '_new_state');\n          delete outputTask._new_state;\n          if (!_.isNull(outputTask._state) && !_.isString(outputTask._state)) {\n            if (_.isNull(self.finishedState) || outputTask._state === false) {\n              // Remove the item if no `finished_state` set in the spec or\n              // _new_state is explicitly set to `false`.\n              return null;\n            }\n            outputTask._state = self.finishedState;\n          }\n          outputTask._state_changed = SERVER_TIMESTAMP;\n          outputTask._owner = null;\n          outputTask._progress = 100;\n          outputTask._error_details = null;\n          return outputTask;\n        }\n        return undefined;\n      }, function(error, committed, snapshot) {\n        /* istanbul ignore if */\n        if (error) {\n          if (++retries < MAX_TRANSACTION_ATTEMPTS) {\n            logger.debug(self._getLogEntry('resolve task errored, retrying'),\n              error);\n            setImmediate(resolve, newTask);\n          } else {\n            var errorMsg = 'resolve task errored too many times, no longer ' +\n              'retrying';\n            logger.debug(self._getLogEntry(errorMsg), error);\n            deferred.reject(new Error(errorMsg));\n          }\n        } else {\n          if (committed && existedBefore) {\n            logger.debug(self._getLogEntry('completed ' + _getKey(snapshot)));\n          } else {\n            logger.debug(self._getLogEntry('Can\\'t resolve task - current ' +\n              'task no longer owned by this process'));\n          }\n          deferred.resolve();\n          self.busy = false;\n          self._tryToProcess();\n        }\n      }, false);\n    }\n\n    return deferred.promise;\n  };\n\n  return resolve;\n};\n\n/**\n * Creates a reject callback function, storing the current task number.\n * @param {Number} taskNumber the current task number\n * @returns {Function} the reject callback function.\n */\nQueueWorker.prototype._reject = function(taskNumber) {\n  var self = this;\n  var retries = 0;\n  var errorString = null;\n  var errorStack = null;\n  var deferred = RSVP.defer();\n\n  /**\n   * Rejects the current task and changes the state to self.errorState,\n   * adding additional data to the '_error_details' sub key.\n   * @param {Object} error The error message or object to be logged.\n   * @returns {RSVP.Promise} Whether the task was able to be rejected.\n   */\n  var reject = function(error) {\n    if ((taskNumber !== self.taskNumber) || _.isNull(self.currentTaskRef)) {\n      if (_.isNull(self.currentTaskRef)) {\n        logger.debug(self._getLogEntry('Can\\'t reject task - no task ' +\n          'currently being processed'));\n      } else {\n        logger.debug(self._getLogEntry('Can\\'t reject task - no longer ' +\n          'processing current task'));\n      }\n      deferred.resolve();\n      self.busy = false;\n      self._tryToProcess();\n    } else {\n      if (_.isError(error)) {\n        errorString = error.message;\n      } else if (_.isString(error)) {\n        errorString = error;\n      } else if (!_.isUndefined(error) && !_.isNull(error)) {\n        errorString = error.toString();\n      }\n\n      if (!self.suppressStack) {\n        errorStack = _.get(error, 'stack', null);\n      }\n\n      var existedBefore;\n      self.currentTaskRef.transaction(function(task) {\n        existedBefore = true;\n        if (_.isNull(task)) {\n          existedBefore = false;\n          return task;\n        }\n        var id = self.processId + ':' + self.taskNumber;\n        if (task._state === self.inProgressState &&\n            task._owner === id) {\n          var attempts = 0;\n          var currentAttempts = _.get(task, '_error_details.attempts', 0);\n          var currentPrevState = _.get(task, '_error_details.previous_state');\n          if (currentAttempts > 0 &&\n              currentPrevState === self.inProgressState) {\n            attempts = currentAttempts;\n          }\n          if (attempts >= self.taskRetries) {\n            task._state = self.errorState;\n          } else {\n            task._state = self.startState;\n          }\n          task._state_changed = SERVER_TIMESTAMP;\n          task._owner = null;\n          task._error_details = {\n            previous_state: self.inProgressState,\n            error: errorString,\n            error_stack: errorStack,\n            attempts: attempts + 1\n          };\n          return task;\n        }\n        return undefined;\n      }, function(transactionError, committed, snapshot) {\n        /* istanbul ignore if */\n        if (transactionError) {\n          if (++retries < MAX_TRANSACTION_ATTEMPTS) {\n            logger.debug(self._getLogEntry('reject task errored, retrying'),\n              transactionError);\n            setImmediate(reject, error);\n          } else {\n            var errorMsg = 'reject task errored too many times, no longer ' +\n              'retrying';\n            logger.debug(self._getLogEntry(errorMsg), transactionError);\n            deferred.reject(new Error(errorMsg));\n          }\n        } else {\n          if (committed && existedBefore) {\n            logger.debug(self._getLogEntry('errored while attempting to ' +\n              'complete ' + _getKey(snapshot)));\n          } else {\n            logger.debug(self._getLogEntry('Can\\'t reject task - current task' +\n              ' no longer owned by this process'));\n          }\n          deferred.resolve();\n          self.busy = false;\n          self._tryToProcess();\n        }\n      }, false);\n    }\n    return deferred.promise;\n  };\n\n  return reject;\n};\n\n/**\n * Creates an update callback function, storing the current task number.\n * @param {Number} taskNumber the current task number\n * @returns {Function} the update callback function.\n */\nQueueWorker.prototype._updateProgress = function(taskNumber) {\n  var self = this;\n  var errorMsg;\n\n  /**\n   * Updates the progress state of the task.\n   * @param {Number} progress The progress to report.\n   * @returns {RSVP.Promise} Whether the progress was updated.\n   */\n  var updateProgress = function(progress) {\n    if (!_.isNumber(progress) ||\n        _.isNaN(progress) ||\n        progress < 0 ||\n        progress > 100) {\n      return RSVP.reject(new Error('Invalid progress'));\n    }\n    if ((taskNumber !== self.taskNumber)  || _.isNull(self.currentTaskRef)) {\n      errorMsg = 'Can\\'t update progress - no task currently being processed';\n      logger.debug(self._getLogEntry(errorMsg));\n      return RSVP.reject(new Error(errorMsg));\n    }\n    return new RSVP.Promise(function(resolve, reject) {\n      self.currentTaskRef.transaction(function(task) {\n        /* istanbul ignore if */\n        if (_.isNull(task)) {\n          return task;\n        }\n        var id = self.processId + ':' + self.taskNumber;\n        if (task._state === self.inProgressState &&\n            task._owner === id) {\n          task._progress = progress;\n          return task;\n        }\n        return undefined;\n      }, function(transactionError, committed, snapshot) {\n        /* istanbul ignore if */\n        if (transactionError) {\n          errorMsg = 'errored while attempting to update progress';\n          logger.debug(self._getLogEntry(errorMsg), transactionError);\n          return reject(new Error(errorMsg));\n        }\n        if (committed && snapshot.exists()) {\n          return resolve();\n        }\n        errorMsg = 'Can\\'t update progress - current task no longer owned ' +\n          'by this process';\n        logger.debug(self._getLogEntry(errorMsg));\n        return reject(new Error(errorMsg));\n      }, false);\n    });\n  };\n\n  return updateProgress;\n};\n\n/**\n * Attempts to claim the next task in the queue.\n */\nQueueWorker.prototype._tryToProcess = function(deferred) {\n  var self = this;\n  var retries = 0;\n  var malformed = false;\n\n  /* istanbul ignore else */\n  if (_.isUndefined(deferred)) {\n    deferred = RSVP.defer();\n  }\n\n  if (!self.busy) {\n    if (!_.isNull(self.shutdownDeferred)) {\n      deferred.reject(new Error('Shutting down - can no longer process new ' +\n        'tasks'));\n      self.setTaskSpec(null);\n      logger.debug(self._getLogEntry('finished shutdown'));\n      self.shutdownDeferred.resolve();\n    } else {\n      if (!self.newTaskRef) {\n        deferred.resolve();\n      } else {\n        self.newTaskRef.once('value', function(taskSnap) {\n          if (!taskSnap.exists()) {\n            return deferred.resolve();\n          }\n          var nextTaskRef;\n          taskSnap.forEach(function(childSnap) {\n            nextTaskRef = _getRef(childSnap);\n          });\n          return nextTaskRef.transaction(function(task) {\n            /* istanbul ignore if */\n            if (_.isNull(task)) {\n              return task;\n            }\n            if (!_.isPlainObject(task)) {\n              malformed = true;\n              var error = new Error('Task was malformed');\n              var errorStack = null;\n              if (!self.suppressStack) {\n                errorStack = error.stack;\n              }\n              return {\n                _state: self.errorState,\n                _state_changed: SERVER_TIMESTAMP,\n                _error_details: {\n                  error: error.message,\n                  original_task: task,\n                  error_stack: errorStack\n                }\n              };\n            }\n            if (_.isUndefined(task._state)) {\n              task._state = null;\n            }\n            if (task._state === self.startState) {\n              task._state = self.inProgressState;\n              task._state_changed = SERVER_TIMESTAMP;\n              task._owner = self.processId + ':' + (self.taskNumber + 1);\n              task._progress = 0;\n              return task;\n            }\n            logger.debug(self._getLogEntry('task no longer in correct state: ' +\n              'expected ' + self.startState + ', got ' + task._state));\n            return undefined;\n          }, function(error, committed, snapshot) {\n            /* istanbul ignore if */\n            if (error) {\n              if (++retries < MAX_TRANSACTION_ATTEMPTS) {\n                logger.debug(self._getLogEntry('errored while attempting to ' +\n                  'claim a new task, retrying'), error);\n                return setImmediate(self._tryToProcess.bind(self), deferred);\n              }\n              var errorMsg = 'errored while attempting to claim a new task ' +\n                'too many times, no longer retrying';\n              logger.debug(self._getLogEntry(errorMsg), error);\n              return deferred.reject(new Error(errorMsg));\n            } else if (committed && snapshot.exists()) {\n              if (malformed) {\n                logger.debug(self._getLogEntry('found malformed entry ' +\n                  _getKey(snapshot)));\n              } else {\n                /* istanbul ignore if */\n                if (self.busy) {\n                  // Worker has become busy while the transaction was processing\n                  // so give up the task for now so another worker can claim it\n                  self._resetTask(nextTaskRef, true);\n                } else {\n                  self.busy = true;\n                  self.taskNumber += 1;\n                  logger.debug(self._getLogEntry('claimed ' + _getKey(snapshot)));\n                  self.currentTaskRef = _getRef(snapshot);\n                  self.currentTaskListener = self.currentTaskRef\n                      .child('_owner').on('value', function(ownerSnapshot) {\n                        var id = self.processId + ':' + self.taskNumber;\n                        /* istanbul ignore else */\n                        if (ownerSnapshot.val() !== id &&\n                            !_.isNull(self.currentTaskRef) &&\n                            !_.isNull(self.currentTaskListener)) {\n                          self.currentTaskRef.child('_owner').off(\n                            'value',\n                            self.currentTaskListener);\n                          self.currentTaskRef = null;\n                          self.currentTaskListener = null;\n                        }\n                      });\n                  var data = snapshot.val();\n                  if (self.sanitize) {\n                    [\n                      '_state',\n                      '_state_changed',\n                      '_owner',\n                      '_progress',\n                      '_error_details'\n                    ].forEach(function(reserved) {\n                      if (snapshot.hasChild(reserved)) {\n                        delete data[reserved];\n                      }\n                    });\n                  } else {\n                    data._id = _getKey(snapshot);\n                  }\n                  var progress = self._updateProgress(self.taskNumber);\n                  var resolve = self._resolve(self.taskNumber);\n                  var reject = self._reject(self.taskNumber);\n                  setImmediate(function() {\n                    try {\n                      self.processingFunction.call(null, data, progress,\n                        resolve, reject);\n                    } catch (err) {\n                      reject(err);\n                    }\n                  });\n                }\n              }\n            }\n            return deferred.resolve();\n          }, false);\n        });\n      }\n    }\n  } else {\n    deferred.resolve();\n  }\n\n  return deferred.promise;\n};\n\n/**\n * Sets up timeouts to reclaim tasks that fail due to taking too long.\n */\nQueueWorker.prototype._setUpTimeouts = function() {\n  var self = this;\n\n  if (!_.isNull(self.processingTaskAddedListener)) {\n    self.processingTasksRef.off(\n      'child_added',\n      self.processingTaskAddedListener);\n    self.processingTaskAddedListener = null;\n  }\n  if (!_.isNull(self.processingTaskRemovedListener)) {\n    self.processingTasksRef.off(\n      'child_removed',\n      self.processingTaskRemovedListener);\n    self.processingTaskRemovedListener = null;\n  }\n\n  _.forEach(self.expiryTimeouts, function(expiryTimeout) {\n    clearTimeout(expiryTimeout);\n  });\n  self.expiryTimeouts = {};\n  self.owners = {};\n\n  if (self.taskTimeout) {\n    self.processingTasksRef = self.tasksRef.orderByChild('_state')\n      .equalTo(self.inProgressState);\n\n    var setUpTimeout = function(snapshot) {\n      var taskName = _getKey(snapshot);\n      var now = new Date().getTime();\n      var startTime = (snapshot.child('_state_changed').val() || now);\n      var expires = Math.max(0, startTime - now + self.taskTimeout);\n      var ref = _getRef(snapshot);\n      self.owners[taskName] = snapshot.child('_owner').val();\n      self.expiryTimeouts[taskName] = setTimeout(\n        self._resetTask.bind(self),\n        expires,\n        ref, false);\n    };\n\n    self.processingTaskAddedListener = self.processingTasksRef.on('child_added',\n      setUpTimeout,\n      /* istanbul ignore next */ function(error) {\n        logger.debug(self._getLogEntry('errored listening to Firebase'), error);\n      });\n    self.processingTaskRemovedListener = self.processingTasksRef.on(\n      'child_removed',\n      function(snapshot) {\n        var taskName = _getKey(snapshot);\n        clearTimeout(self.expiryTimeouts[taskName]);\n        delete self.expiryTimeouts[taskName];\n        delete self.owners[taskName];\n      }, /* istanbul ignore next */ function(error) {\n        logger.debug(self._getLogEntry('errored listening to Firebase'), error);\n      });\n    self.processingTasksRef.on('child_changed', function(snapshot) {\n      // This catches de-duped events from the server - if the task was removed\n      // and added in quick succession, the server may squash them into a\n      // single update\n      var taskName = _getKey(snapshot);\n      if (snapshot.child('_owner').val() !== self.owners[taskName]) {\n        setUpTimeout(snapshot);\n      }\n    }, /* istanbul ignore next */ function(error) {\n      logger.debug(self._getLogEntry('errored listening to Firebase'), error);\n    });\n  } else {\n    self.processingTasksRef = null;\n  }\n};\n\n/**\n * Validates a task spec contains meaningful parameters.\n * @param {Object} taskSpec The specification for the task.\n * @returns {Boolean} Whether the taskSpec is valid.\n */\nQueueWorker.prototype._isValidTaskSpec = function(taskSpec) {\n  if (!_.isPlainObject(taskSpec)) {\n    return false;\n  }\n  if (!_.isString(taskSpec.inProgressState)) {\n    return false;\n  }\n  if (!_.isUndefined(taskSpec.startState) &&\n      !_.isNull(taskSpec.startState) &&\n      (\n        !_.isString(taskSpec.startState) ||\n        taskSpec.startState === taskSpec.inProgressState\n      )) {\n    return false;\n  }\n  if (!_.isUndefined(taskSpec.finishedState) &&\n      !_.isNull(taskSpec.finishedState) &&\n      (\n        !_.isString(taskSpec.finishedState) ||\n        taskSpec.finishedState === taskSpec.inProgressState ||\n        taskSpec.finishedState === taskSpec.startState\n      )) {\n    return false;\n  }\n  if (!_.isUndefined(taskSpec.errorState) &&\n      !_.isNull(taskSpec.errorState) &&\n      (\n        !_.isString(taskSpec.errorState) ||\n        taskSpec.errorState === taskSpec.inProgressState\n      )) {\n    return false;\n  }\n  if (!_.isUndefined(taskSpec.timeout) &&\n      !_.isNull(taskSpec.timeout) &&\n      (\n        !_.isNumber(taskSpec.timeout) ||\n        taskSpec.timeout <= 0 ||\n        taskSpec.timeout % 1 !== 0\n      )) {\n    return false;\n  }\n  if (!_.isUndefined(taskSpec.retries) &&\n      !_.isNull(taskSpec.retries) &&\n      (\n        !_.isNumber(taskSpec.retries) ||\n        taskSpec.retries < 0 ||\n        taskSpec.retries % 1 !== 0\n      )) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Sets up the listeners to claim tasks and reset them if they timeout. Called\n *   any time the task spec changes.\n * @param {Object} taskSpec The specification for the task.\n */\nQueueWorker.prototype.setTaskSpec = function(taskSpec) {\n  var self = this;\n\n  // Increment the taskNumber so that a task being processed before the change\n  // doesn't continue to use incorrect data\n  self.taskNumber += 1;\n\n  if (!_.isNull(self.newTaskListener)) {\n    self.newTaskRef.off('child_added', self.newTaskListener);\n  }\n\n  if (!_.isNull(self.currentTaskListener)) {\n    self.currentTaskRef.child('_owner').off(\n      'value',\n      self.currentTaskListener);\n    self._resetTask(self.currentTaskRef, true);\n    self.currentTaskRef = null;\n    self.currentTaskListener = null;\n  }\n\n  if (self._isValidTaskSpec(taskSpec)) {\n    self.startState = taskSpec.startState || null;\n    self.inProgressState = taskSpec.inProgressState;\n    self.finishedState = taskSpec.finishedState || null;\n    self.errorState = taskSpec.errorState || DEFAULT_ERROR_STATE;\n    self.taskTimeout = taskSpec.timeout || null;\n    self.taskRetries = taskSpec.retries || DEFAULT_RETRIES;\n\n    self.newTaskRef = self.tasksRef\n                          .orderByChild('_state')\n                          .equalTo(self.startState)\n                          .limitToFirst(1);\n    logger.debug(self._getLogEntry('listening'));\n    self.newTaskListener = self.newTaskRef.on(\n      'child_added',\n      function() {\n        self._tryToProcess();\n      }, /* istanbul ignore next */ function(error) {\n        logger.debug(self._getLogEntry('errored listening to Firebase'), error);\n      });\n  } else {\n    logger.debug(self._getLogEntry('invalid task spec, not listening for new ' +\n      'tasks'));\n    self.startState = null;\n    self.inProgressState = null;\n    self.finishedState = null;\n    self.errorState = DEFAULT_ERROR_STATE;\n    self.taskTimeout = null;\n    self.taskRetries = DEFAULT_RETRIES;\n\n    self.newTaskRef = null;\n    self.newTaskListener = null;\n  }\n\n  self._setUpTimeouts();\n};\n\nQueueWorker.prototype.shutdown = function() {\n  var self = this;\n\n  if (!_.isNull(self.shutdownDeferred)) {\n    return self.shutdownDeferred.promise;\n  }\n\n  logger.debug(self._getLogEntry('shutting down'));\n\n  // Set the global shutdown deferred promise, which signals we're shutting down\n  self.shutdownDeferred = RSVP.defer();\n\n  // We can report success immediately if we're not busy\n  if (!self.busy) {\n    self.setTaskSpec(null);\n    logger.debug(self._getLogEntry('finished shutdown'));\n    self.shutdownDeferred.resolve();\n  }\n\n  return self.shutdownDeferred.promise;\n};\n\nmodule.exports = QueueWorker;\n"}